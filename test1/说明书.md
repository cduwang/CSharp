# LCS（Longest Common Subsequence）
- 最长公共子序列，它是求两个字符串最长公共子序列的问题。
- 假设字符串存放于数组中，他们的LCS也存放于数组Z[k]中，且这两个数组分别为X[i]和Y[j]。 如果两个数组的最后两个字符相同，即X[i-1]==Y[j-1]，那么对于我们的数组Z[k-1]== X[i-1]==Y[j-1]， 此时问题就变成了求X[i-1]和Y[j-1]的LCS；如果X[i-1]!=Y[j-1]，那就相当于求解X[i-1]和Y[j-1-1]的LCS或者是X[i-1-1]Y[j-1]的LCS， 选择其中大的作为LCS的最终值，后面的问题一直这样循环的找下去。直到i==0&&j==0。
- 定义一个LCS类用来计算LCS，将两个数组看作是矩阵的行和列， 首先定义两个私有成员变量lcs_length和lcs_dir两个二维数组作为存储的矩阵式， 其中lcs_length用于存放两个字符串比较后的LCS数；lcs_dir是一个二维数组用于存储lcs_length阵中对应位所指向的方向， 到后面根据lcs_dir方向阵中存储的方向进行回溯查询LCS串。在LCS类中，定义一个lcs_num函数进行LCS的运算， 并使用泛型来接收将要进行运算的不确定类型的两个数组，使用.length获取数组的长度， 然后通过for()循环对前面定义的lcs_length和lcs_dir进行对应的填充。 首先是矩阵的第一行和第一列的每个元素依次进行比较， 如果有相同元素的，就在对应的lcs_length的对应行列位置填充1，lcs_dir的对应位置将方向填为“左上”， 即只有方位阵中记为左上的才是有着相同元素的；
- 如果其中行数在第一行，列数不在第一列，且比较后的元素不同， 就将对应ij位置的lcs_length记为上一列的数并且lcs_dir对应位记为“左”， 如果列数是1而行数不是1，就将lcs_length记为上一行的数且lcs_dir对应位记为“上”， 以上是在初始时第一行与第一列的比较情况。然后是其他行列， 如果在比较的途中发现有相同元素的，就把对应ij位置的lcs_length填充为其左上角的数值+1，即i-1，j-1位置的数值+1， 也就是LCS+1且将lcs_dir中对应位置记为“左上”；如果元素不同，就看是对应位置上面的LCS大，还是左面的LCS大，取其中的最大值， 上面的大就在lcs_dir中记为“上”，左面的大就在lcs_dir中记为“左”。
- 以上就是一个比较并记录数据的过程， 根据上述过程会形成LCS数值的表和用于回溯输出LCS的方向表。两个表对应相同，只是其中的数据不同。 从表的右下方开始进行回溯，其中右下方的lcs_length表中的数值就是LCS的数值， 回溯就是根据方向表中的方向不中断的往回走将子串找出来，表中是“上”就往上移动一行，是“左”就往左移动一列， 是“左上”就表明两个数组的元素相同，将其取出作为子串的元素，然后再移动到左上的表格位置去， 采用递归的方式进行打印，如此回溯，直到i=0,j=0，最终就会得到子串。
